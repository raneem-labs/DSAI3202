import numpy as np
import multiprocessing
import time

def calculate_fitness(route, distance_matrix):
    """
    Calculate the total distance traveled by the car (fitness function).

    Parameters:
        - route (list): A list representing the order of nodes visited in the route.
        - distance_matrix (numpy.ndarray): A matrix of the distances between nodes.

    Returns:
        - float: The negative total distance traveled (to minimize the distance).
          Returns a large negative penalty (negative infinity) if the route is infeasible.
    """
    # Get all consecutive pairs of nodes in the route
    node_pairs = np.array([route, route[1:] + [route[0]]]).T  # Including return to start
    
    # Get distances between consecutive nodes
    distances = distance_matrix[node_pairs[:, 0], node_pairs[:, 1]]
    
    # Check if any distance is infinity (infeasible route)
    if np.any(distances == np.inf):
        return -np.inf
    
    # Calculate the total distance
    total_distance = np.sum(distances)
    
    # Return the negative of the total distance (to minimize)
    return -total_distance

def select_in_tournament(population, scores, number_tournaments=4, tournament_size=3):
    """
    Tournament selection for genetic algorithm.

    Parameters:
        - population (list): The current population of routes.
        - scores (np.array): The calculate_fitness scores corresponding to each individual in the population.
        - number_tournaments (int): The number of the tournaments to run in the population.
        - tournament_size (int): The number of individuals to compete in the tournaments.

    Returns:
        - list: A list of selected individuals for crossover.
    """
    tournament_indices = []
    scores = np.array(scores)
    
    for _ in range(len(population) // 2):  # Number of tournaments
        indices = np.random.choice(len(population), tournament_size, replace=False)
        tournament_scores = scores[indices]
        best_index = indices[np.argmin(tournament_scores)]  # Minimize score
        tournament_indices.append(best_index)
    
    return [population[i] for i in tournament_indices]

def select_elites(population, fitness_values, elite_size=5):
    """
    Elite Selection: Keep the top N best individuals from the current generation.
    """
    elite_indices = np.argsort(fitness_values)[-elite_size:]
    elites = [population[i] for i in elite_indices]
    return elites

def order_crossover(parent1, parent2):
    """
    Order crossover (OX) for permutations.

    Parameters:
        - parent1 (list): The first parent route.
        - parent2 (list): The second parent route.

    Returns:
        - list: The offspring route generated by the crossover.
    """
    size = len(parent1)
    start, end = sorted(np.random.choice(range(size), 2, replace=False))

    offspring = [None] * size
    offspring[start:end + 1] = parent1[start:end + 1]

    fill_values = [x for x in parent2 if x not in offspring]
    idx = 0
    for i in range(size):
        if offspring[i] is None:
            offspring[i] = fill_values[idx]
            idx += 1
            
    return offspring

def mutate(route, mutation_rate=0.1, generation=0, max_generations=100):
    """
    Mutation operator with adaptive mutation rate.

    The mutation rate decreases over time as the algorithm progresses.

    Parameters:
        - route (list): The route to mutate.
        - mutation_rate (float): The initial chance to mutate an individual.
        - generation (int): The current generation number.
        - max_generations (int): The total number of generations.

    Returns:
        - list: The mutated route.
    """
    # Dynamically adjust the mutation rate based on the generation
    adaptive_mutation_rate = mutation_rate * (1 - generation / max_generations)
    
    if np.random.rand() < adaptive_mutation_rate:
        i, j = np.random.choice(len(route), 2, replace=False)
        route[i], route[j] = route[j], route[i]
    
    return route


def generate_unique_population(population_size, num_nodes):
    """
    Generate a unique population of individuals for a genetic algorithm.

    Each individual in the population represents a route in a graph, where the first node is fixed (0) and the 
    remaining nodes are a permutation of the other nodes in the graph. This function ensures that all individuals
    in the population are unique.

    Parameters:
        - population_size (int): The desired size of the population.
        - num_nodes (int): The number of nodes in the graph, including the starting node.

    Returns:
        - list of lists: A list of unique individuals, where each individual is represented as a list of node indices.
    """
    population = []
    
    while len(population) < population_size:
        individual = [0] + list(np.random.permutation(np.arange(1, num_nodes)))
        if individual not in population:
            population.append(individual)
            
    return population

def evaluate_population(population, distance_matrix):
    """
    Parallel fitness evaluation function using multiprocessing.
    """
    with multiprocessing.Pool(processes=multiprocessing.cpu_count()) as pool:
        fitness_values = pool.map(lambda ind: calculate_fitness(ind, distance_matrix), population)
    return fitness_values

